class MinHeap { constructor() { this.heap = []; } getLeftIndex = (i) => i * 2 + 1; getRightIndex = (i) => i * 2 + 2; getParentIndex = (i) => Math.floor((i - 1) / 2); push(value) { this.heap.push(value); this.heapifyUp(); } heapifyUp() { let index = this.heap.length - 1; while (index > 0) { const parentIndex = this.getParentIndex(index); if (this.heap[parentIndex] <= this.heap[index]) break; [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]]; index = parentIndex; } } pop() { if (this.heap.length === 0) return null; if (this.heap.length === 1) return this.heap.pop(); const root = this.heap[0]; this.heap[0] = this.heap.pop(); this.heapifyDown(); return root; } heapifyDown() { let index = 0; const length = this.heap.length; while (this.getLeftIndex(index) < length) { const left = this.getLeftIndex(index); const right = this.getRightIndex(index); let smaller = left; if (right < length && this.heap[right] < this.heap[left]) smaller = right; if (this.heap[index] <= this.heap[smaller]) break; [this.heap[index], this.heap[smaller]] = [this.heap[smaller], this.heap[index]]; index = smaller; } } peek() { return this.heap[0]; } size() { return this.heap.length; } } function solution(scoville, K) { const heap = new MinHeap(); scoville.forEach((s) => heap.push(s)); let count = 0; while (heap.size() > 1 && heap.peek() < K) { const first = heap.pop(); const second = heap.pop(); const mixed = first + second * 2; heap.push(mixed); count++; } return heap.peek() >= K ? count : -1; }